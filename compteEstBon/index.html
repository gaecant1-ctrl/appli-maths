<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Jeu ‚ Retrouver l'expression</title>

<!-- MathJax -->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

<style>
body{margin:0;font-family:Arial;background:#eef1f4}
header{background:#0055aa;color:#fff;padding:14px;text-align:center;font-size:1.4em;font-weight:bold}
#grille{display:flex;justify-content:center;gap:14px;margin:25px}
.jeton{background:#fff;padding:14px 20px;border-radius:8px;font-size:1.4em;box-shadow:0 2px 6px rgba(0,0,0,.25)}
.vert{background:#b8f5b8!important}
#panel{text-align:center}
input{font-size:1.2em;padding:8px;width:420px}
button{font-size:1.1em;padding:8px 18px;margin-left:10px}
#btnNext{display:none}
#message{margin-top:15px;font-size:1.2em;min-height:25px;text-align:center}
.jeton.faux{ background:#f8caca }
.jeton.utilise{ outline:3px solid #0055aa }
#etat{
  background:#0055aa;
  color:white;
  padding:12px;
  text-align:center;
  font-size:1.1em;
  font-weight:bold;
}

#consigne{
  background:#ffffff;
  margin:15px auto 0 auto;
  padding:16px;
  max-width:720px;
  border-radius:10px;
  box-shadow:0 2px 6px rgba(0,0,0,.15);
  text-align:center;
  font-size:1.4em;
}

</style>
</head>

<body>

<header id="etat"></header>
<div id="consigne"></div>




<div id="grille"></div>

<div id="panel">
  <input
  id="expr"
  placeholder="Ex : (3*9):7"
  autocomplete="off"
  autocorrect="off"
  autocapitalize="off"
  spellcheck="false"
/>

  <button id="btnValider">Valider</button>
  <button id="btnNext">Suivant</button>
  <div id="debugSolution" style="
  max-width:720px;
  margin:12px auto;
  padding:12px;
  background:#fff6d8;
  border:2px dashed #e0b000;
  border-radius:10px;
  display:none;
  text-align:center;
">
  <div id="solutionTexte" style="font-size:1.2em;margin-bottom:8px;"></div>
  <button id="btnDebugNext">Suivant (test)</button>
</div>
</div>

<div id="message"></div>

<!-- ==================== FRACTION ==================== -->
<script src="Fraction.js"></script>

<!-- ==================== SCRIPT PRINCIPAL ==================== -->
<script>

// ==================== NIVEAU ====================
const DEBUG = false;

const niveau = new Niveau6(); // ou new Niveau5()

const OPS = ["+","-","*",":"];

const NB_QUESTIONS = 10;

let questionIndex = 0; // commence √† 0
let score = 0;



function rand(){
  return Math.floor(Math.random()*9)+1;
}

// ==================== CALCUL FRACTION ====================
function applyOp(a, op, b){
  switch(op){
    case "+": return new Fraction(
      a.nb*b.db + b.nb*a.db,
      a.db*b.db
    );
    case "-": return new Fraction(
      a.nb*b.db - b.nb*a.db,
      a.db*b.db
    );
    case "*": return new Fraction(
      a.nb*b.nb,
      a.db*b.db
    );
    case ":":
      if(b.nb === 0) return null;
      return new Fraction(
        a.nb*b.db,
        a.db*b.nb
      );
  }
}

// ==================== PARSER STRICT ====================
function parseExpressionStrict(expr, jetons){

  expr = expr.replace(/\s+/g,"");

  const numsDisponibles = jetons.map(j => j.nb.toString());
  const steps = [];

  // ─────────────────────────────────────────
  // 1) formes AVEC parenthèses (inchangées)
  // ─────────────────────────────────────────

  // (a op b) op c
  let m1 = expr.match(/^\((\d+)([+\-*:])(\d+)\)([+\-*:])(\d+)$/);
  if(m1){
    const [_, a, op1, b, op2, c] = m1;
    if(!checkJetons([a,b,c], numsDisponibles)) return null;

    const A = new Fraction(+a,1);
    const B = new Fraction(+b,1);
    const C = new Fraction(+c,1);

    const r1 = applyOp(A, op1, B);
    if(!r1) return null;
    steps.push({ gauche:A, op:op1, droite:B, resultat:r1 });

    const r2 = applyOp(r1, op2, C);
    if(!r2) return null;
    steps.push({ gauche:r1, op:op2, droite:C, resultat:r2 });

    return {
      resultat: r2,
      steps,
      initialLatex: `(${a}${latexOp(op1)}${b})${latexOp(op2)}${c}`
    };
  }

  // a op (b op c)
  let m2 = expr.match(/^(\d+)([+\-*:])\((\d+)([+\-*:])(\d+)\)$/);
  if(m2){
    const [_, a, op1, b, op2, c] = m2;
    if(!checkJetons([a,b,c], numsDisponibles)) return null;

    const A = new Fraction(+a,1);
    const B = new Fraction(+b,1);
    const C = new Fraction(+c,1);

    const r1 = applyOp(B, op2, C);
    if(!r1) return null;
    steps.push({ gauche:B, op:op2, droite:C, resultat:r1 });

    const r2 = applyOp(A, op1, r1);
    if(!r2) return null;
    steps.push({ gauche:A, op:op1, droite:r1, resultat:r2 });

    return {
      resultat: r2,
      steps,
      initialLatex: `${a}${latexOp(op1)}(${b}${latexOp(op2)}${c})`
    };
  }

  // ─────────────────────────────────────────
  // 2) NOUVELLE FORME : SANS parenthèses
  // ─────────────────────────────────────────

  let m3 = expr.match(/^(\d+)([+\-*:])(\d+)([+\-*:])(\d+)$/);
  if(m3){
    const [_, a, op1, b, op2, c] = m3;
    if(!checkJetons([a,b,c], numsDisponibles)) return null;

    const A = new Fraction(+a,1);
    const B = new Fraction(+b,1);
    const C = new Fraction(+c,1);

    const prio = op => (op==="*" || op===":") ? 2 : 1;

    // priorité à droite
    if(prio(op2) > prio(op1)){
      const r1 = applyOp(B, op2, C);
      if(!r1) return null;
      steps.push({ gauche:B, op:op2, droite:C, resultat:r1 });

      const r2 = applyOp(A, op1, r1);
      if(!r2) return null;
      steps.push({ gauche:A, op:op1, droite:r1, resultat:r2 });

      return {
        resultat: r2,
        steps,
        initialLatex: `${a}${latexOp(op1)}${b}${latexOp(op2)}${c}`
      };
    }

    // priorité à gauche (ou égalité)
    const r1 = applyOp(A, op1, B);
    if(!r1) return null;
    steps.push({ gauche:A, op:op1, droite:B, resultat:r1 });

    const r2 = applyOp(r1, op2, C);
    if(!r2) return null;
    steps.push({ gauche:r1, op:op2, droite:C, resultat:r2 });

    return {
      resultat: r2,
      steps,
      initialLatex: `${a}${latexOp(op1)}${b}${latexOp(op2)}${c}`
    };
  }

  return null;
}


// ==================== JETONS ====================

function extractNumbers(expr){
  return expr.match(/\d+/g) || [];
}


function countOccurrences(arr){
  const c = {};
  arr.forEach(x => c[x] = (c[x] || 0) + 1);
  return c;
}


function sameJetons(used, available){
  return used.slice().sort().join(",") ===
         available.slice().sort().join(",");
}


function feedbackJetons(expr){
  const used = extractNumbers(expr);
  document.querySelectorAll(".jeton").forEach(j=>{
    if(used.includes(j.textContent)){
      j.classList.add("utilise");
    } else {
      j.classList.remove("utilise");
    }
  });
}

function checkJetons(used, available){
  return used.slice().sort().join(",") ===
         available.slice().sort().join(",");
}

function contexte(op, gauche, droite){
  return {
    op,
    gauche:{
      valeur: gauche.nb / gauche.db,
      type: (gauche.db === 1 ? "entier" : "fraction")
    },
    droite:{
      valeur: droite.nb / droite.db,
      type: (droite.db === 1 ? "entier" : "fraction")
    }
  };
}

// ==================== G√âN√âRATION ====================
// ==================== CLASSES DE R√âSULTATS ====================

function classeFraction(f){
  if(f.isEntier()) return "entier";

  if(f.estDecimaleExacte()) return "decimal";

  if(Math.abs(f.n) < Math.abs(f.d)) return "fraction_simple";

  return "mixte";
}


function generate(){

  while(true){

    const a = new Fraction(rand(),1);
    const b = new Fraction(rand(),1);
    const c = new Fraction(rand(),1);

    const valeurs = [a,b,c];

    const resultatsParClasse = {
      entier: [],
      fraction_simple: [],
      decimal: [],
      mixte: []
    };

    const perms = [
      [valeurs[0],valeurs[1],valeurs[2]],
      [valeurs[0],valeurs[2],valeurs[1]],
      [valeurs[1],valeurs[0],valeurs[2]],
      [valeurs[1],valeurs[2],valeurs[0]],
      [valeurs[2],valeurs[0],valeurs[1]],
      [valeurs[2],valeurs[1],valeurs[0]],
    ];

    for(const [x,y,z] of perms){
      for(const op1 of OPS){
        for(const op2 of OPS){

          // (x op1 y) op2 z
          if(niveau.autoriseOperation(contexte(op1,x,y))){
            const r1 = applyOp(x,op1,y);
            if(r1 && niveau.autoriseOperation(contexte(op2,r1,z))){
              const r2 = applyOp(r1,op2,z);
              if(r2){
                const cl = classeFraction(r2);
                resultatsParClasse[cl].push({
                  resultat: r2,
                  expr: `(${x.nb}${op1}${y.nb})${op2}${z.nb}`
                });
              }
            }
          }

          // x op1 (y op2 z)
          if(niveau.autoriseOperation(contexte(op2,y,z))){
            const r1 = applyOp(y,op2,z);
            if(r1 && niveau.autoriseOperation(contexte(op1,x,r1))){
              const r2 = applyOp(x,op1,r1);
              if(r2){
                const cl = classeFraction(r2);
                resultatsParClasse[cl].push({
                  resultat: r2,
                  expr: `${x.nb}${op1}(${y.nb}${op2}${z.nb})`
                });
              }
            }
          }

        }
      }
    }

    // d√©duplication math√©matique
    for(const cl in resultatsParClasse){
      const uniques = [];
      resultatsParClasse[cl].forEach(obj=>{
        if(!uniques.some(u => u.resultat.equals(obj.resultat))){
          uniques.push(obj);
        }
      });
      resultatsParClasse[cl] = uniques;
    }

    // on exige au moins une fraction possible
    if(
      resultatsParClasse.fraction_simple.length === 0 &&
      resultatsParClasse.mixte.length === 0
    ){
      continue;
    }

    return { a, b, c, resultatsParClasse };
  }
}



// ==================== LATEX ====================
function latexOp(op){
  return op==="*"?"\\times":op;
}

function buildExpressionLatex(gauche, op, droite){
  const g = (typeof gauche==="string") ? gauche : gauche.toLatex();
  const d = (typeof droite==="string") ? droite : droite.toLatex();
  return `${g} ${latexOp(op)} ${d}`;
}

function latexSteps(parsed, statutFinalImpose){
  const steps = parsed.steps;
  let lines = [];

  let currentLatex = parsed.initialLatex;
  lines.push(currentLatex);

  steps.forEach((s,i)=>{
    let resLatex = (i===steps.length-1)
      ? s.resultat.toLatex(statutFinalImpose)
      : s.resultat.toLatex();

    // parenth√®ses UNIQUEMENT si le r√©sultat est r√©utilis√© dans une op√©ration
if(i < steps.length - 1 && resLatex.includes("+")){
  resLatex = `\\big(${resLatex}\\big)`;
}


    if(i===steps.length-1){
      lines.push(resLatex);
      return;
    }

    const next = steps[i+1];
    if(next.gauche === s.resultat){
      currentLatex = buildExpressionLatex(resLatex,next.op,next.droite);
    } else {
      currentLatex = buildExpressionLatex(next.gauche,next.op,resLatex);
    }
    lines.push(currentLatex);
  });

  return `
\\[
\\begin{array}{l}
&${lines[0]} \\\\
${lines.slice(1).map(l=>`=& ${l}`).join(" \\\\ ")}
\\end{array}
\\]
`;
}

// ==================== JEU ====================
let game, phase="saisie";

// ==================== √âQUILIBRAGE DU QUIZ ====================

const frequencesCibles = {
  entier: 0.30,
  fraction_simple: 0.30,
  decimal: 0.20,
  mixte: 0.20
};

const statsQuiz = {
  entier: 0,
  fraction_simple: 0,
  decimal: 0,
  mixte: 0
};

function choisirClasse(resultatsParClasse){

  const total = questionIndex || 1;

  const classesPossibles =
    Object.keys(resultatsParClasse)
      .filter(c => resultatsParClasse[c].length > 0);

  const etats = classesPossibles.map(c => ({
    classe: c,
    retard: (statsQuiz[c] / total) - frequencesCibles[c]
  }));

  etats.sort((a,b) => a.retard - b.retard);

  return etats[0].classe;
}


function nouvellePartie(){

  if(questionIndex >= NB_QUESTIONS){
    phase = "fin";
    etat.innerHTML =
      "Fin du jeu ‚ Score final : " + score + " / " + NB_QUESTIONS;
    consigne.innerHTML = "";
    grille.innerHTML = "";
    btnValider.style.display = "none";
    btnNext.style.display = "none";
    expr.disabled = true;
    message.textContent = "";
    return;
  }

  questionIndex++;

  game = generate();

  const classeCible = choisirClasse(game.resultatsParClasse);
  const candidats = game.resultatsParClasse[classeCible];
  const sol = candidats[Math.random()*candidats.length|0];

  game.target = sol.resultat;
  game.solutionExpr = sol.expr;
  game.classe = classeCible;

  // ‚úÖ STATISTIQUE AU BON ENDROIT
  statsQuiz[game.classe]++;

  phase = "saisie";

  etat.innerHTML =
    "Question " + questionIndex + " / " + NB_QUESTIONS +
    ", Score : " + score + " / " + (questionIndex - 1);

  consigne.innerHTML =
    "Trouve une expression pour obtenir :<br>\\(" +
    game.target.toLatex(game.target.statut) +
    "\\)";

  MathJax.typesetPromise();

  grille.innerHTML="";
  [game.a, game.b, game.c]
    .map(f => f.nb.toString())
    .sort(()=>Math.random()-0.5)
    .forEach(n=>{
      const d = document.createElement("div");
      d.className = "jeton";
      d.textContent = n;
      grille.appendChild(d);
    });

  expr.value = "";
  expr.disabled = false;
  btnValider.style.display = "inline-block";
  btnNext.style.display = "none";
  message.textContent = "";
  expr.focus();

  const debug = document.getElementById("debugSolution");
  const solTxt = document.getElementById("solutionTexte");

  solTxt.innerHTML =
    "Solution possible : \\(" +
    game.solutionExpr.replace(/\*/g,"\\times").replace(/:/g,"\\div") +
    "\\)";

  debug.style.display = DEBUG ? "block" : "none";
  if(DEBUG) MathJax.typesetPromise();
}




function valider(){
  if(phase !== "saisie") return;

  // ‚îÄ‚îÄ 1) Extraction des nombres utilis√©s
  const usedNums = extractNumbers(expr.value);
  const availableNums = [game.a, game.b, game.c].map(f => f.nb.toString());

  // ‚îÄ‚îÄ Comptage des occurrences
  const usedCount = countOccurrences(usedNums);

  // ‚îÄ‚îÄ 2) Reset visuel des jetons
  document.querySelectorAll(".jeton").forEach(j=>{
    j.classList.remove("vert","faux","utilise");
  });

  // ‚îÄ‚îÄ 3) V√©rification stricte des jetons
  const bonsJetons = checkJetons(usedNums, availableNums);

  // ‚îÄ‚îÄ 4) Parsing (structure + calculabilit√©)
  const parsed = parseExpressionStrict(
    expr.value,
    [game.a, game.b, game.c]
  );

  // ‚îÄ‚îÄ CAS 1 : mauvais jetons (manquants ou doublons)
  if(!bonsJetons){
    message.textContent =
      "Tu dois utiliser chaque jeton exactement une fois.";

    // consommation jeton par jeton (gestion des doublons)
    const remaining = { ...usedCount };

    document.querySelectorAll(".jeton").forEach(j=>{
      const n = j.textContent;

      if(remaining[n] && remaining[n] > 0){
        j.classList.add("vert");
        remaining[n]--;
      } else {
        j.classList.add("faux");
      }
    });

    expr.focus();
    return;
  }

  // ‚îÄ‚îÄ CAS 2 : structure non calculable
  if(!parsed){
    message.textContent =
      "L'expression n'est pas calculable (structure ou opérations interdites).";

    document.querySelectorAll(".jeton")
      .forEach(j => j.classList.add("vert"));

    expr.focus();
    return;
  }

  // ‚îÄ‚îÄ 5) √Ä partir d‚Äôici : calculable (juste ou faux)
  const latex = latexSteps(parsed, game.target.statut);

  // ‚îÄ‚îÄ CAS 3 : r√©ponse correcte
  if(parsed.resultat.equals(game.target)){
    score++;   // ‚≠ê incr√©ment du score
    statsQuiz[game.classe]++;


    phase = "next";
    btnValider.style.display = "none";
    btnNext.style.display = "inline-block";

    document.querySelectorAll(".jeton")
      .forEach(j => j.classList.add("vert"));

    message.innerHTML =
      "Bravo ! Le calcul est correct." + latex;

    MathJax.typesetPromise();
    return;
  }

  // ‚îÄ‚îÄ CAS 4 : calcul faux mais valide
  phase = "next";
  btnValider.style.display = "none";
  btnNext.style.display = "inline-block";

  document.querySelectorAll(".jeton")
    .forEach(j => j.classList.add("vert"));

  message.innerHTML =
    "Ton expression ne donne pas \\(" +
    game.target.toLatex(game.target.statut) +
    "\\)." +
    latex;

  MathJax.typesetPromise();
  

}





  // ‚îÄ‚îÄ √† partir d‚Äôici : calculable (juste ou faux)


// ==================== CLAVIER ====================
document.addEventListener("keydown",e=>{
  if(e.key!=="Enter") return;
  e.preventDefault();
  if(phase==="saisie") valider();
  else nouvellePartie();
});

document.getElementById("btnDebugNext").onclick = () => {
  nouvellePartie();
};


nouvellePartie();
btnValider.onclick=valider;
btnNext.onclick=nouvellePartie;

</script>

</body>
</html>
